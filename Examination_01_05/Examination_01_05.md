#  ☁️☁️☁️☁️☁️ `APUE` 阶段性检测 ☁️☁️☁️☁️☁️

* **检测范围: Chapter 1 ~ Chapter 5**

* **题型：填空题、画图题、代码分析题、编程题、实验探究题**

* **试卷满分：300分**
****

### 一、填空题（140分）
1. 请为右侧名词作出定义，**内核**是 ____、**系统调用（`system call`）**是 _____、**公用库函数**是 ___、**`shell`** 是 _____
2. 在 `Linux` 操作系统中，用户的登录名取自 ______ 文件中的登陆项，此登陆项中包含有下列信息：________、 _________、 _________、 ________、 ________、 ________、 ________
3. 目录是一种包含 _________ 的文件，每个（**前一个空的答案**） _________ 至少包含 _________ 和 ___________
4. 请描述 `相对路径` 和 `绝对路径` 的区别：_____
5. 工作目录是指 ______，改变和查看工作目录可以使用函数 _____ 和 _____（**填写函数原型**）
6. 文件描述符是指 ______、不同进程间的文件描述符 ________ （***会/不会***）相同，原因是 _____ 
7. 请辨析 `程序` 和 `进程`：____________________________
8. 不同进程中的线程 ID __________ （**会/不会**）相同。
6. 描述 `shell` 命令 `prog1 < inputfile | prog2 | prog3 > outputfile` 的作用  __________________________。
7. 信号的作用是 ________________________________、操作系统有三种处理信号的方式，分别为 ____________________________、________、___________。为相应的信号注册捕获函数可以使用 ______ （***填写函数原型***），______（***填写函数原型***）。
7. `墙上时钟时间` 指的是 ______________________、`用户 CPU 时间` 指的是 _________________________、`系统 CPU 时间`指的是 _________________________，测量程序执行的三种上述时间可以使用的 `shell` 命令是 _______
8. `带缓冲的 I/O` 一词中，`缓冲`指的是 ____，`带缓冲的 I/O` 其优势在于：______________________________________________________________
9. 分别解释下列标志位的作用：`O_EXCL`，`O_APPEND`，`O_TRUNC`，
`O_SYNC`，`O_DSYNC`，`O_NONFOLLOW` ______________________________
10. 描述两种获取文件大小的方式 ____________,___________。
15. `creat` 相当于调用 `open(file_path`, _______, `flags)`
16. 对于 `read` 和 `write` 缓冲区尺寸的选取，最恰当的选择是 ____________ 
17. 列举所有文件类型和判断该类型的宏，并分别对其作一定的介绍或阐述其用途 ____
18. 列举 `struct stat` 中至少 7 个字段，并分别对每个字段作一定的介绍 ____________
19. `fgets()` 在出错时返回 _______，在读到文件末尾时返回 __________，`fputs()` 在出错时返回 ________，在成功时返回 _________，因为 ____________，所以需要使用 `feof()` 和 `ferror()` 来区分 ______
20. `umask()` 的作用是 ______________，`0644` 表示的访问权限是 _________，在 umask 值为 `0022` 的进程中设置创建文件的访问权限位 `0777`，那么最终创建文件的访问权限位为 _____
21. 与一个进程相关的 `ID` 有 ___________________________
22. 获取与进程相关的 `ID` 的函数有 ______，设置与进程相关的 `ID` 的函数有 ______
23. 请分别解释 `S_ISUID` 和 `S_ISGID` 的作用 ___________
24. 打开目录下的某个文件需要对这个目录拥有 _________ 权限。
25. 在目录下创建一个文件需要对目录拥有 __________ 权限。
26. 删除目录下的某个文件需要对目录拥有 __________ 权限。对文件 ________ （需要/不需要）权限。
27. 进程打开、创建、删除文件时，内核就会进行文件访问权限测试:第一步 ______，第二步 ______，第三步 _____，第四步 ______
28. `access()` 函数测试文件是否可读，可写，可执行，是否存在时，内核进行的文件访问权限测试与上一题中有何不同？____ 
29. `chown` 的作用是 ______，`chmod` 的作用是 _______，`chroot` 的作用是 _______

### 二、画图题（30分）
> 要求：画出`进程表项`，`文件表项`和 `v节点表项`以及 `i节点`，并用有方向的箭头绘制出它们之间的逻辑关系。

1. 画出同一进程打开两个不同文件的内核数据结构。
2. 画出两个不同进程各自打开同一文件的内核数据结构。
3. 画出 `dup(1)` 之后的内核数据结构（假设在此期间该进程没有打开任何文件）。
4. 画出 `./a.out > outfile 2>&1` 命令在执行期间的一系列内核数据结构变化（假设在此期间该进程没有打开任何文件）。
5. 画出 `./a.out 2>&1 > outfile` 命令在执行期间的一系列内核数据结构变化（假设在此期间该进程没有打开任何文件）。
6. 画出文件系统的图。表达出数据块，目录块和 `i` 节点数组的概念。

-
### 三、分析题（50分）

##### 1、执行如下代码将在终端上输出什么？为什么？

```C
1|  int main() {
2|     printf("hello world");
3|     _exit(0);
4|  }
```

##### 2、在第 1 题的基础上添加一行代码后如下所示，执行后将在终端输出什么？为什么？

```C
1|  int main() {
2|     setbuf(stdout, NULL);
3|     printf("hello world");
4|     _exit(0);
5|  }
```

##### 3、在第 2 题的基础上修改代码后如下所示，执行后将在终端输出什么？为什么？

```C
1|  int main() {
2|	   char buf[11] = { 0 };
3|     setbuf(stdout, buf);
4|     printf("hello world");
5|     _exit(0);
6|  }
```

##### 4、在第 3 题的基础上修改代码后如下所示，执行后将在终端输出什么？为什么？

```C
1|  int main() {
2|	   char buf[11] = { 0 };
3|     setvbuf(stdout, buf, _IOFBF, sizeof(buf));
4|     printf("hello world");
5|     _exit(0);
6|  }
```

##### 5、在第 3 题的基础上修改代码后如下所示，执行后将在终端输出什么？为什么？

```C
1|  int main() {
2|	   char buf[12] = { 0 };
3|     setvbuf(stdout, buf, _IOFBF, sizeof(buf));
4|     printf("hello world");
5|     return 0;
6|  }
```


##### 6、首先执行如下代码： 

```C
1|  unsigned char str[] = { 'a', 'b', 'c', 0, 'e', 0, 'g', '\n', 'i', 'j', 'k', 0};
2|  int fd = open("test_file", O_WRONLY | O_CREAT | O_TRUNC, 0644);
3|  write(fd, str, sizeof(str));
4|  close(fd);
```
##### （1）写出文件 `test_file` 的大小和此时的内容。

##### 假设有如下函数定义

```C
5|  void printbuf(char *buf, int size) {
6|     for (int i = 0; i < size; i++) 
7|        printf("%c", buf[i] == 0 ? '@' : buf[i] == '\n' ? '~' : buf[i]);
8|     printf("\n");
9|  }
```

##### 接下来执行如下代码：

```C
10|  FILE *fp = fopen("test_file", "r");
11|  char fp_buf[9] = { 0 };
12|  setvbuf(fp, fp_buf, _IOFBF, sizeof(fp_buf));
13|  char buf[4] = { 0 };
14|  while (fgets(buf, sizeof(buf), fp) != NULL) {

		  #1
15|      printbuf((char *)fp->_bf._base, fp->_bf._size);
    
    	  #2
16|      printbuf(buf, sizeof(buf));
17|  }
```

##### （2）写出每次迭代中 `#1` 和 `#2` 打印的内容。


-
### 四、编程题（30分）

##### 1、 实现下列代码中所需的宏函数 `LOG(format, ...)` ，并将其编写在文件 `exam_prog1.c` 中，按如下所示导入头文件，编译运行程序，完成如图所示的输出。 

```C
#include "exam_prog1.c"

int main(int argc, char *argv[]) {
	
	char buf[10 << 10] = { 0 };
    setvbuf(stdout, buf, _IOFBF, sizeof(buf));
    printf(" ShenZheng, ");
    printf("Nice to meet you\n");
    
    LOG("Good morning, ");
    LOG("I'm %s, and I live in", "Hanson");
    char *ptr = NULL;
    LOG(ptr);

    fflush(stdout);
    _exit(0);    
}
```
##### 该程序产生如下终端输出：

```C
➜ Good morning, I'm Hanson, and I live in Shenzheng, Nice to meet you 
```


##### 2、使用 `dup(int fd)` 实现 `my_dup2(int fd)` 函数，并将其编写在文件 `exam_prog2.c` 中，按如下方式导入头文件，编译运行程序，完成如图所示的输出。

```C
#include "exam_prog2.c"

int main(int argc, char *argv[]) {
    
    close(2);
    if (my_dup2(2, 5) < 0) 
        printf("my_dup2 fail 1: %s\n", strerror(errno));
    else
        printf("my_dup2 succ 1\n");

    if (my_dup2(1, 1000) < 0) 
        printf("my_dup2 fail 2: %s\n", strerror(errno));
    else
        printf("my_dup2 succ 2\n");

    int fd = open("test_file", O_RDWR | O_CREAT | O_TRUNC, 0644);
    if (my_dup2(1, fd) < 0)
        printf("my_dup2 fail 3: %s\n", strerror(errno));
    else
        printf("my_dup2 succ 3\n");

    const char *ptr = "hello world to stdout\n";
    write(fd, ptr, strlen(ptr));

    if (my_dup2(1, 1) < 0)
        printf("my_dup2 fail 4: %s\n", strerror(errno));
    else
        printf("my_dup2 succ 4\n");
    
    return 0;    
}
```

##### 3、编写程序 `myftw.c`， 该程序的功能是：从一个起始目录开始，统计此目录下各种文件的数目。编译运行该程序，将 `\` 作为命令行参数传入，给出终端输出以及该 `myftw.c` 文件作为测试解答提交（下面给出该程序的一些输出示例）。

```C
➜ ./myftw 
usage : ./myftw <beg_file_path>

➜ ./myftw /
/usr/sbin/authserver/ open dir fail : Permission denied
/usr/local/openfire/ open dir fail : Permission denied
^C
【操作被打断！】
目录 : 8196
普通文件 : 77698
fifo : 0
socket : 0
块特殊设备 : 0
字符特殊设备 : 0
符号链接 : 5879

➜ ./myftw ~/Desktop 
目录 : 8678
普通文件 : 65503
fifo : 3
socket : 0
块特殊设备 : 0
字符特殊设备 : 0
符号链接 : 101
```  

### 四、实验探究题（50分）

> 下面各题均需提交完整可编译运行的代码文件。

##### 1. 列举三种使 `write(...)` 调用返回 `-1` 的情形，同时列举一种使 `write(...)` 的返回值不等于需写入字节数的情形。分别用代码构建上述四种场景，编译运行程序，给出用户友好的输出提示，将代码文件命名为 `write_neg_return.c` 作为测试解答提交。
##### 2. 列举三种使 `read(...)` 调用返回 `-1` 的情形，列举两种使 `read(...)` 返回 `0` 的情形。分别用代码构建上述五种场景，编译运行程序，给出用户友好的输出提示，将代码文件命名为 `read_neg_return.c` 和 `read_zero_return.c` 作为测试解答提交。

##### 3、编写程序 `copy.c` 的三个版本。
##### （1）分别使用 `read`/`write`、`fgets`/`fputs`、`fread`/`fwrite`来实现拷贝文件功能。
##### （2）给出三种版本的拷贝程序对测试代码和运行结果。
##### （3）在你的三种版本的拷贝程序中，使用 `fgets`/`fputs` 和 `fread`/`fwrite` 的版本的运行结果是否和你预期的相符？若不相符，试着探究其原因。（提示：带空洞和不带空洞会影响 `fgets`/`fputs` 的表现；而 `fread` 在返回 0 时可能读到一个不完整的结构）  





	
	






 
